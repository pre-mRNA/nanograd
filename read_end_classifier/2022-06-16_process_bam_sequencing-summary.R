#!/usr/bin/env Rscript

# info

# consolidate sequencing summary data with read-specific degradation data
# uses nanograd4 temporary output file
# written by AS and BK on 2022-06-20


#################################################

# for command line use only

args = commandArgs(trailingOnly=TRUE) # ignore when running interactively

# test if there is at least one argument: if not, return an error

if (length(args)!=5) {
  stop("\nUsage: Rscript proccess_bam_sequencing_summary.R /path/to/bar.gtf /path/to/bamdata.txt /path/to/minknow_sequencing_summary.txt \"sample\" /path/to/output.txt", call.=FALSE) # ignore when running interactively
}

##################################################

# test command for interactive use (Bhavika's computer)

#args <- c("C:/Users/Sujata\ Kumar/Documents/localGadiData_windows/2022-06-20_process_bam_sequencing-summary/transcriptOnly_Homo_sapiens.GRCh38.104.chr.gtf", "C:/Users/Sujata\ Kumar/Documents/localGadiData_windows/2022-06-20_process_bam_sequencing-summary/all.5mM_MgCl_degrdation_pass2.fastq.gz.sorted_nanograd4_out.txt.temp", "C:/Users/Sujata\ Kumar/Documents/localGadiData_windows/2022-06-20_process_bam_sequencing-summary/sequencing_summary_5mM_MgCl_degradation_pass2.txt", "5mM_degradation_rep2", "C:/Users/Sujata\ Kumar/Documents/localGadiData_windows/2022-06-20_process_bam_sequencing-summary/merged_SS_5mM_degradation_rep2.txt")

#################################################

# load libraries

library(tidyverse)
library(GenomicFeatures)
library(rtracklayer)

#################################################

# function to import a .temp file generated by nanograd
input <- read_tsv(args[2], col_names = F, col_types = "ffcc") %>%
  dplyr::rename(read_id = 1, tx = 2, seq = 4, cig = 3) %>%
  mutate(seq_len = nchar(seq)) %>%
  dplyr::select(-seq)

############################################################
############################################################
############################################################

# process the nanograd temporary file

# parse CIGAR
matcher <- function(pattern, x) {
  ind = gregexpr(pattern, x)[[1]]
  start = as.numeric(ind)
  end = start + attr(ind, "match.length")- 2
  apply(cbind(start,end), 1, function(y) substr(x, start=y[1], stop=y[2]));
}

doone <- function(c, cigar) {
  pat <- paste("\\d+", c , sep="")
  sum(as.numeric(matcher(pat, cigar)), na.rm=T)
}

## takes a cigar string and parses it, not very fast but...
cigarsums <- function(cigar, chars=c("M")) {
  sapply (chars, doone, cigar)
}

# calculate matches
addcig <- input %>%
  rowwise %>% mutate(map_len = cigarsums(cig)) %>%
  dplyr::select(-cig)

rm(input)

# as a sanity check, look at the relationship between sequencing length and mapped length in a scatterplot
# plot(addcig$seq_len, addcig$map_len)
# cor.test(addcig$seq_len, addcig$map_len)

############################################################
############################################################
############################################################

#### here is where you want to import the sequencing_summary
#### keep only the read_id, start_time, duration, and end_reason

seq_data <- read_tsv(args[3], col_names = T, col_types = "ffffiiddffff") %>%
  dplyr::select(read_id, end_reason, start_time, duration)

############################################################
############################################################
############################################################

# merge the data from the bam (addcig) with the data from sequencing summary and write to 'annotate'
annotate <- inner_join(addcig, seq_data, by = "read_id")

# clean up
rm(addcig, seq_data)

############################################################
############################################################
############################################################

# process the annotation to get a vector of transcripts, biotypes, and transcript_lengths

# create a variable for the annotation
anno <- args[1]

# read in reference transcripts
gtf <- makeTxDbFromGFF(file=anno, format = "gtf")

# make an exon database from the reference transcripts
exons <- exonsBy(gtf, "tx", use.names=TRUE)

# convert the transcripts to a tibble
exons_tib <- as_tibble(as(exons, "data.frame"))

# fetch the lengthe of each transcript segment from the gtf
txlen <- transcriptLengths(gtf, with.cds_len=TRUE, with.utr5_len=TRUE, with.utr3_len=TRUE) %>%
  as_tibble() %>%
  mutate(diff = tx_len - cds_len - utr5_len - utr3_len) %>%
  dplyr::rename(transcript_id = tx_name) %>%
  dplyr::select(-tx_id, -nexon, -gene_id, -diff)

# the last command doesn't store biotype, so we read in the gtf again using another package
tx_biotype <- rtracklayer::import(anno) %>%
  as_tibble() %>%
  dplyr::select(transcript_id, transcript_biotype, gene_name, gene_id) %>%
  na.omit() %>%
  distinct()

# merge the biotypes with the transcript segment lengths
merged_metadata <- inner_join(tx_biotype, txlen, by = "transcript_id") %>%
  dplyr::select(-cds_len, -utr5_len, -utr3_len) # note: these variables only work when using the full gtf

# clean up and remove temporary transcriptome variables (keep merged_metadata)
rm(gtf, txlen, tx_biotype)

# join data to decay
output <- inner_join(annotate %>% separate(tx, into=c("transcript_id", "transcript_version"), sep = "([.])", extra = "merge") %>% dplyr::select(-transcript_version),
                     merged_metadata, by = "transcript_id") %>%
  mutate(df = map_len / tx_len)

############################################################
############################################################
### join data, testing using left_join to find incomplete cases -- start
# join data to decay
# output_tmp <- left_join(annotate %>% separate(tx, into=c("transcript_id", "transcript_version"), sep = "([.])", extra = "merge") %>% dplyr::select(-transcript_version),
#                      merged_metadata, by = "transcript_id") %>%
#   mutate(df = map_len / tx_len)
#
# # get column names
# colnms <- colnames(output_tmp)
#
# # filter for incomplete rows
# tmp <- output_tmp %>%
#   filter_at(vars(all_of(colnms)), any_vars(is.na(.)))
#
# # get transcript_ids for incomplete cases
# missing_ids <- tmp %>% dplyr::select(transcript_id) %>% unique()

### join data, testing using left_join to find incomplete cases -- end
############################################################
############################################################

# clean
rm(annotate, merged_metadata)

############################################################
############################################################
############################################################

# exploratory analysis of output

# # calculate transcript abundance for protein_coding transcripts
# tx_counts <- output %>%
#   filter(transcript_biotype == "protein_coding") %>%
#   group_by(transcript_id) %>%
#   mutate(n = n()) %>%
#   ungroup() %>%
#   arrange(desc(n))
#
# # plot transcript counts
# ggplot(tx_counts, aes(x = n)) + geom_histogram() + scale_x_log10() + scale_y_log10()
#
# # find the most abundant transcript
# most_abun <- tx_counts %>% arrange(desc(n)) %>% head(n = 1) %>% dplyr::select(transcript_id)
# most_abun
# # ENST00000361624
#
# # now, filter the output for this transcript
# my_abun <- output %>% filter(transcript_id == "ENST00000361624")
#
# # compare start time to decay factor for this gene
# ggplot(my_abun, aes(x = start_time, y = df)) + geom_point()
#
# # make a global plot of sequencing duration vs sequence length
# ggplot(output, aes(x = duration, y=seq_len)) + geom_point()
# cor.test(output$duration, output$seq_len)
#
# # perform a global test to check start_time vs sequencing_duration
# ggplot(output, aes(x = start_time, y=duration)) + geom_point()
# cor.test(output$start_time, output$duration)

############################################################
############################################################
############################################################

#### old code to calculate decay factor per-read rather than per-transcript as a summary

# calculate per-read decay factor for every read in 'annotate'

# calculate transcript abundance
# commented out as this summarises by transcript

# txabund <- addcig %>%
#   group_by(tx) %>%
#   mutate(nread = n()) %>%
#   arrange(desc(nread)) %>%
#  ungroup()

# calculate decay factor per groups transcript
# commented out because this summarises

# decay <- txabund %>%
#   dplyr::select(-read, -nread) %>%
#   group_by(tx) %>%
#   summarise(df = median(map_len), cov = n())

############################################################
############################################################
############################################################

# finish the script

# add condition
output <- output %>% mutate(condition = args[4])

# write output to tab_separated file with headers
write_tsv(output, args[5], col_names = T)
print(paste(date(), "Done"))
